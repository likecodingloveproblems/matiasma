// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: session.sql

package models

import (
	"context"
	"time"
)

const getUserLatestSession = `-- name: GetUserLatestSession :one
SELECT session_data, created_at
FROM telegram_sessions
WHERE phone_number = $1
ORDER BY created_at DESC
LIMIT 1
`

type GetUserLatestSessionRow struct {
	SessionData []byte
	CreatedAt   time.Time
}

func (q *Queries) GetUserLatestSession(ctx context.Context, phoneNumber string) (GetUserLatestSessionRow, error) {
	row := q.db.QueryRowContext(ctx, getUserLatestSession, phoneNumber)
	var i GetUserLatestSessionRow
	err := row.Scan(&i.SessionData, &i.CreatedAt)
	return i, err
}

const upsertSession = `-- name: UpsertSession :exec
INSERT INTO telegram_sessions (phone_number, session_data, created_at)
VALUES ($1, $2, $3)
ON CONFLICT (phone_number)
    DO UPDATE SET
    session_data = EXCLUDED.session_data
`

type UpsertSessionParams struct {
	PhoneNumber string
	SessionData []byte
	CreatedAt   time.Time
}

func (q *Queries) UpsertSession(ctx context.Context, arg UpsertSessionParams) error {
	_, err := q.db.ExecContext(ctx, upsertSession, arg.PhoneNumber, arg.SessionData, arg.CreatedAt)
	return err
}
